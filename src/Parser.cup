import java_cup.runtime.*;
import java.util.ArrayList;
import classes.*;
import classes.function.*;
import classes.declarations.*;
import classes.expr.*;
import classes.expr.assignments.*;
import classes.expr.binaryExpr.*;
import classes.expr.consts.*;
import classes.expr.unaryExpr.*;
import classes.expr.variables.*;
import classes.expr.binaryExpr.arithmetic.*;
import classes.expr.binaryExpr.conditional.*;
import classes.statements.*;
import classes.statements.conditionalSts.*;
import classes.statements.loopSts.*;
import classes.statements.conditionalSts.switchSts.*;

import java.util.Collections;

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
//init with {: s.init(); :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            BREAK, CASE,CHAR,CONST,CONTINUE,DEFAULT,DOUBLE,ELSE,END,EXTERN,FUNCTION,FLOAT,FOR,IF,INT,LONG,RETURN,RECORD,SIZEOF,STRING,SWITCH,NULL_LITERAL,LPAREN,RPAREN,
                    LBRACE,RBRACE,LBRACK,RBRACK,SEMICOLON,COMMA,DOT,EQ,GT,LT,COLON,EQEQ,LTEQ,GTEQ,NOTEQ,PLUS,PLUSPLUS,MINUSMINUS,MINUS,MULT,DIV,BITWISE_AND,BITWISE_OR,XOR,MOD,
                    PLUSEQ,MINUSEQ,MULTEQ,DIVEQ,LOGICAL_AND,VOID,AUTO,OF,TILDA,LOGICAL_OR,BOOL,BEGIN,REPEAT,UNTIL,FOREACH,IN,UMINUS,DUMMY,NOT;

terminal INTEGER_LITERAL;
terminal LONG_LITERAL;
terminal FLOAT_LITERAL;
terminal DOUBLE_LITERAL;
terminal BOOLEAN_LITERAL;
terminal CHARACTER_LITERAL;
terminal IDENTIFIER,STRING_LITERAL;

/* Non terminals */
non terminal  program,func_extern,func_dcl,extern_dcl,arguments,type,struct_dec,var_dcl,var_dcl_cnt,block,statement,assignment,method_call,cond_stmt,var_dcls
              ,loop_stmt,expr,variable,binary_op,arithmatic,conditional,const_val,filled_brackets,square_brackets,argument_helper,var_dcl_cnts,cases,parameters,short_form_operator,block_content;

/* Precedences */
precedence right DUMMY;
precedence right EQ;
precedence left LOGICAL_AND, LOGICAL_OR;
precedence left BITWISE_OR;
precedence left XOR;
precedence left BITWISE_AND;
precedence left EQEQ, NOTEQ;
precedence left LTEQ,LT, GTEQ, GT;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence right TILDA;
precedence left UMINUS;
precedence left DOT ;
precedence left LBRACK, RBRACK, LPAREN ,RPAREN;


/* The grammar rules */

program ::= program:e1 var_dcl:e2       {:RESULT = ((Program)e1).add((Part)e2);:}
        | program:e1 func_extern:e2     {:RESULT = ((Program)e1).add((Part)e2);:}
        | program:e1 struct_dec:e2      {:RESULT = ((Program)e1).add((Part)e2);:}
        |                               {:RESULT = new Program();:}
        ;

func_extern ::= func_dcl:e {: RESULT = e;:}
            | extern_dcl:e {: RESULT = e;:}
            ;

func_dcl ::=  FUNCTION type:e1 IDENTIFIER:e2 LPAREN RPAREN SEMICOLON
              {:RESULT = new FuncDcl((String)e1, (String)e2,new ArrayList<Argument>(), null);:}
            | FUNCTION type:e1 IDENTIFIER:e2 LPAREN RPAREN block:e3
              {:RESULT = new FuncDcl((String)e1, (String)e2,new ArrayList<Argument>(), (Block)e3);:}
            | FUNCTION type:e1 IDENTIFIER:e2 LPAREN arguments:e3 RPAREN SEMICOLON
              {:RESULT = new FuncDcl((String)e1, (String)e2, (ArrayList<Argument>)e3,null);:}
            | FUNCTION type:e1 IDENTIFIER:e2 LPAREN arguments:e3 RPAREN block:e4
              {:RESULT = new FuncDcl((String)e1, (String)e2, (ArrayList<Argument>)e3, (Block)e4);:}
            ;

extern_dcl ::= EXTERN type:e1 IDENTIFIER:e2 SEMICOLON
              {:RESULT = new ExternDcl((String)e1,(String)e2);:}
            ;

arguments ::= type:e1 IDENTIFIER:e2 argument_helper:e3
              {: ArrayList<Argument> a = new ArrayList <>() ;
                a.add(new Argument((String)e1, (String)e2,(Integer)e3)); RESULT = a ; :}
            | arguments:e1 COMMA type:e2 IDENTIFIER:e3 argument_helper:e4
              {:
                ArrayList<Argument> a = ((ArrayList<Argument>)e1);
                a.add(new Argument((String)e2, (String)e3,(Integer)e4));
                RESULT = a;:}
            ;

argument_helper ::=  argument_helper:e square_brackets {:RESULT = ((Integer)e)+1;:}
                    | {:RESULT = Integer.valueOf(0);:} ;

square_brackets ::= LBRACK RBRACK;

type ::= INT:e        {:RESULT = e;:}
        |BOOL:e       {:RESULT = e;:}
        |FLOAT:e      {:RESULT = e;:}
        |LONG:e       {:RESULT = e;:}
        |CHAR:e       {:RESULT = e;:}
        |DOUBLE:e     {:RESULT = e;:}
        |IDENTIFIER:e {:RESULT = e;:}
        |STRING:e     {:RESULT = e;:}
        |VOID:e       {:RESULT = e;:}
        |AUTO:e       {:RESULT = e;:}
        ;

struct_dec ::= RECORD IDENTIFIER:e1 BEGIN var_dcls:e2 END SEMICOLON
               {:RESULT = new Struct((String) e1,(ArrayList<VarDcl>)e2);:};

var_dcls ::= var_dcls:e1 var_dcl:e2 {:ArrayList<VarDcl> dcls = (ArrayList<VarDcl>) e1;
                                        dcls.add((VarDcl) e2);
                                        RESULT = dcls;:}
            | var_dcl:e1            {:ArrayList<VarDcl> dcls = new ArrayList<>();
                                        dcls.add((VarDcl) e1);
                                        RESULT = dcls;:}
            ;

var_dcl ::= CONST type:e1 var_dcl_cnt:e2 var_dcl_cnts:e3 SEMICOLON
        {:ArrayList <VarDclPart> a = (ArrayList <VarDclPart>) e3;
        a.add((VarDclPart)e2); Collections.reverse(a); RESULT = new VarDcl(true,(String)e1,a);:}
            |type:e1 var_dcl_cnt:e2 var_dcl_cnts:e3 SEMICOLON
        {:ArrayList <VarDclPart> a = (ArrayList <VarDclPart>) e3;
        a.add((VarDclPart)e2); Collections.reverse(a); RESULT = new VarDcl(false,(String)e1,a);:}
            ;
var_dcl_cnts ::=	COMMA var_dcl_cnt:e1 var_dcl_cnts:e2
                {: ArrayList <VarDclPart> a = (ArrayList <VarDclPart>) e2;
                    a.add((VarDclPart)e1); RESULT = a ; :}
			|	{: RESULT = new ArrayList <VarDclPart>() ; :}
			;

var_dcl_cnt ::= IDENTIFIER:e1 {:RESULT = new VarDclPart((String)e1,null);:}
                | IDENTIFIER:e1 EQ expr:e2 {:RESULT = new VarDclPart((String)e1,(Expr)e2);:};

block ::= BEGIN block_content:e END {:RESULT = new Block((ArrayList <Operation>)e);:}
        ;

block_content ::= block_content:e1 var_dcl:e2
                {: ArrayList <Operation> a = (ArrayList <Operation>) e1 ;
                 a.add((Operation)e2); RESULT = a;
                :}
                | block_content:e1 statement:e2
                {:ArrayList <Operation> a = (ArrayList <Operation>) e1 ;
                 a.add((Operation)e2); RESULT = a;
                :}
                | {:RESULT = new ArrayList<Operation>();:}
                ;

statement ::= assignment:e SEMICOLON    {:RESULT = new AssignmentSt((Assignment)e);:}
            | method_call:e SEMICOLON   {:RESULT =e;:}
            | cond_stmt:e               {:RESULT =e;:}
            | loop_stmt:e               {:RESULT =e;:}
            | RETURN expr:e SEMICOLON   {:RESULT = new Return((Expr)e); :}
            | RETURN SEMICOLON          {:RESULT = new Return(); :}
            | BREAK SEMICOLON           {:RESULT = new Break(); :}
            | CONTINUE SEMICOLON        {:RESULT = new Continue();:}
            ;

assignment ::= variable:e1 short_form_operator:e2 expr:e3
            {:Assignment a = (Assignment) e2;
              a.setDetail((Variable)e1,(Expr)e3);
              RESULT = a;:}
            ;

short_form_operator ::= EQ {:RESULT = new Eq();:}
                        |PLUSEQ {:RESULT = new PEq();:}
                        | MINUSEQ {: RESULT = new MEq();:}
                        | MULTEQ  {:RESULT = new MuEq();:}
                        | DIVEQ {:RESULT = new DEq();:}
                        ;

method_call ::= IDENTIFIER:e LPAREN RPAREN {:RESULT = new FuncCall((String)e,new Parameters());:}
                | IDENTIFIER:e1 LPAREN parameters:e2 RPAREN
                                        {:RESULT = new FuncCall((String)e1,(Parameters)e2);:}
                ;

parameters ::= expr:e   {:Parameters p = new Parameters(); p.add((Expr)e); RESULT = p;:}
             | parameters:e1 COMMA expr:e2
                        {:Parameters p = (Parameters)e1; p.add((Expr)e2); RESULT = p;:};

cond_stmt ::= IF LPAREN expr:e1 RPAREN block:e2
            {:RESULT = new If((Expr)e1,(Block)e2,null);:}
            | IF LPAREN expr:e1 RPAREN block:e2 ELSE block:e3
            {:RESULT = new If((Expr)e1,(Block)e2,(Block)e3);:}
            | SWITCH LPAREN IDENTIFIER:e1 RPAREN OF COLON BEGIN cases:e2 DEFAULT COLON block:e3 END
            {:RESULT = new Switch((Expr)e1, (ArrayList <Case>)e2, (Block) e3) ;:}
            ;

cases ::= cases:e1 CASE INTEGER_LITERAL:e2 COLON block:e3
         {:ArrayList <Case> a = (ArrayList <Case>)e1;
         a.add(new Case(new IntCExpr(Integer.parseInt((String)e2)),(Block)e3)); RESULT = a ;:}
        | {:RESULT = new ArrayList<Case>();:}
        ;

loop_stmt ::= FOR LPAREN assignment:e1 SEMICOLON expr:e2 SEMICOLON assignment:e3 RPAREN block:e4
             {:RESULT = new For((Assignment)e1,(Expr)e2,(Assignment)e3,(Block)e4);:}
             |FOR LPAREN assignment:e1 SEMICOLON expr:e2 SEMICOLON expr:e3 RPAREN block:e4
             {:RESULT = new For((Assignment)e1,(Expr)e2,(Expr)e3,(Block)e4);:}
             |FOR LPAREN assignment:e1 SEMICOLON expr:e2 SEMICOLON RPAREN block:e3
             {:RESULT = new For((Assignment)e1,(Expr)e2,null,(Block)e3);:}
             |FOR LPAREN SEMICOLON expr:e1 SEMICOLON assignment:e2 RPAREN block:e3
             {:RESULT = new For(null,(Expr)e1,(Assignment)e2,(Block)e3);:}
             |FOR LPAREN SEMICOLON expr:e1 SEMICOLON expr:e2 RPAREN block:e3
             {:RESULT = new For(null,(Expr)e1,(Expr)e2,(Block)e3);:}
             |REPEAT block:e1 UNTIL LPAREN expr:e2 RPAREN SEMICOLON
             {:RESULT = new Repeat((Block)e1,(Expr)e2);:}
             |FOREACH LPAREN IDENTIFIER:e1 IN IDENTIFIER:e2 RPAREN block:e3
             {:RESULT = new Foreach((String)e1, (String)e2,(Block)e3);:}
             ;

expr ::= expr:e1 binary_op:e2 expr:e3 {:RESULT = ((BinaryExpr)e2).setExpressions((Expr)e1,(Expr)e3);:}
        | LPAREN expr:e RPAREN        {:RESULT = new Parenthesized((Expr)e);:}
        | method_call:e               {:RESULT = e;:}
        | variable:e                  {:RESULT = e;:}
        | const_val:e                 {:RESULT = e;:}
        | MINUS expr:e                {:RESULT = new UMinus((Expr)e);:}
           %prec UMINUS
        | TILDA expr:e                {:RESULT = new UNot((Expr)e);:}
        | NOT expr:e                  {:RESULT = new UNot((Expr)e); :}
        | SIZEOF LPAREN type:e RPAREN {:RESULT = new SizeOfExpr((String)e); :}
        | variable:e MINUSMINUS       {:RESULT = new MM((Expr)e);:}
            %prec DUMMY
        | MINUSMINUS variable:e       {:RESULT = new MM((Expr)e);:}
        | PLUSPLUS variable:e         {:RESULT = new PP((Expr)e);:}
        | variable:e PLUSPLUS         {:RESULT = new PP((Expr)e);:}
            %prec DUMMY ;

variable ::= IDENTIFIER:e {:RESULT = new SimpleVar((String)e);:}
            |IDENTIFIER:e1 filled_brackets:e2
                          {:RESULT = new ArrayVar((String)e1,(ArrayList <Expr>)e2);:}
            | variable:e1 DOT IDENTIFIER:e2
                          {:RESULT = new StructVar((Variable)e1, (String)e2);:}
            ;

filled_brackets ::= filled_brackets:e1 LBRACK expr:e2 RBRACK
                    {:ArrayList<Expr> a=(ArrayList <Expr>)e1;a.add((Expr)e2); RESULT = a;:}
                    | LBRACK expr:e RBRACK
                    {:ArrayList<Expr> a=new ArrayList<>();a.add((Expr)e); RESULT = a;:}
                    ;

binary_op ::= arithmatic:e  {:RESULT = e;:}
            | conditional:e {:RESULT = e;:}
            ;

arithmatic ::= PLUS         {:RESULT = new Plus();:}
            | MINUS         {:RESULT = new Minus();:}
            | MULT          {:RESULT = new Mult();:}
            | DIV           {:RESULT = new Divide();:}
            | MOD           {:RESULT = new Mod();:}
            | BITWISE_AND   {:RESULT = new BitwiseAnd();:}
            | BITWISE_OR    {:RESULT = new BitwiseOr();:}
            | XOR           {:RESULT = new Xor();:}
            ;

conditional ::= EQEQ        {:RESULT = new EqEq();:}
            | LTEQ          {:RESULT = new LTEq();:}
            | GTEQ          {:RESULT = new GTEq();:}
            | NOTEQ         {:RESULT = new NotEq();:}
            | GT            {:RESULT = new GT();:}
            | LT            {:RESULT = new LT();:}
            | LOGICAL_AND   {:RESULT = new And();:}
            | LOGICAL_OR    {:RESULT = new Or();:}
            ;

const_val ::= INTEGER_LITERAL:e   {:RESULT = new IntCExpr(Integer.parseInt((String)e));:}
            | LONG_LITERAL:e      {:RESULT = new LongCExpr(Long.parseLong((String)e));:}
            | FLOAT_LITERAL:e     {:RESULT = new FloatCExpr(Float.parseFloat((String)e));:}
            | DOUBLE_LITERAL:e    {:RESULT = new DoubleCExpr(Double.parseDouble((String)e));:}
            | BOOLEAN_LITERAL:e   {:RESULT = new BooleanCExpr(Boolean.parseBoolean((String)e));:}
            | CHARACTER_LITERAL:e {:RESULT = new CharCExpr(((String)e).charAt(0));:}
            | STRING_LITERAL:e    {:RESULT = new StringCExpr((String)e);:}
            ;

